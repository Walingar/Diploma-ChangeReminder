\documentclass[times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}

\studygroup{M3435}
\title{Предсказание забытых для модификации файлов на основе Git репозитория}
\author{Рыкунов Николай Викторович}{Рыкунов Н.В.}
\supervisor{Сметанников Иван Борисович}{Сметанников И.Б.}{доцент, к.т.н.}{научный сотрудник университета ИТМО}
\publishyear{2020}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{сентября}{2018}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2019}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2019}

\addconsultant{Поваров Н.И.}{ООО "ИнтеллиДжей Лабс"{}, Аналитик}

\secretary{Павлова О.Н.}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

В данном разделе размещается введение.

%% Начало содержательной части.
\chapter{Первая глава}

%% Так помечается начало обзора.
\startrelatedwork
Обзор
%% Так помечается конец обзора.
\finishrelatedwork


\chapter{Перевод статьи}
\section{Введение}
Git является распределенной системой контроля версий. Система контроля версий помогает разработчику сохранить проделанную работу локально или на сервер. Проектная информация хранится в специальной базе данных, которая называется репозиторий. Репозиторий состоит из некоторого множества снимков изменений, которые именуются коммит. Каждый коммит в свою очередь состоит из ссылки на предыдущий коммит (если имеется), мета-информации (сообщение, автор, время коммита), и самих зафиксированных изменений. В среднем разработчик в большом проекте делает несколько коммитов в день. Они фиксируются в репозитории. Проектов, использующих систему контроля версий Git, большое количество. Таким образом, на данный момент накоплена очень большая кодовая база. Её часть является открытой, например, всем известный сайт GitHub на январь 2020 года содержал более чем 28 миллионов открытых репозиториев. Такая кодовая база неявно хранит в себе шаблоны поведения разработчиков, настройки их окружения и другие интересные для анализа данные. Используя этот набор данных, мы можем помочь разработчикам избежать ошибок, приводивших к неконсистентному состоянию репозитория в прошлом.
\section{Работы}
Перед началом выполнения выпускной работы, были проанализировано несколько статей на тему дипломной работы и смежные темы. В мировом индексе представлено множество работ, где рассказано о том, как можно использовать исторические данные в процессе разработки программного обеспечения с целью повышения качества этого процесса. Был подход использования кодовой базы для поиска логически связанных модулей, чтобы отследить, какие файлы изменяются вместе \cite{logical-modules}. В статье \cite{source-change} автор разрабатывал систему предсказаний о том, какие изменения внесет разработчик в кодовую базу. Были проанализированы статьи, которые не имеют непосредственного отношения к выпускной работе, но подходы из этих статей использовались при разработке модели предсказаний. Одна из таких статей \cite{project-memory}. В данной статье авторы разработали приложение Hipikat, позволяющие новым участникам быстрее ознакомится с программной системой, с которой им предстоит работать.
\section{Актуальность}
В настоящее время не сложно представить себе такую ситуацию. Предположим, у нас есть команда из двух разработчиков (Р1 и Р2). Однажды произошла приведенная ниже цепочка событий:
    \begin{enumerate}
		\item Р1 пишет некоторый код.
		\item Р1 делает commit и push изменений в репозиторий на сервере.
		\item Р2 делает pull изменений с сервера, в результате у него появляются изменения Р1.
		\item Р2 собирает проект, запускает код, но программа стала работать неправильно.
		\item Р2 пишет письмо Р1, что Р1 написал некорректно работающий код. 
		\item Р1 исследует проблему и замечает, что он забыл изменить конфигурационный файл, связанный с измененным им раннее кодом.
		\item Р1 модифицирует код в конфигурационном файле.
		\item Р1 делает commit и push изменений в репозиторий на сервере.
		\item Р2 делает pull изменений с сервера, в результате у него появляются новые изменения Р1.
		\item Р2 собирает проект, запускает код. Теперь программа работает корректно.
	\end{enumerate}
Цепочка событий могла бы быть значительно короче, если бы Р1 не забыл модифицировать конфигурационный файл, который было важно изменить при модификации окружающего кода. В идеальном мире нам хотелось бы всегда видеть такую картину:
    \begin{enumerate}
		\item Р1 пишет некоторый код.
		\item Р1 делает commit и push изменений в репозиторий на сервере.
		\item Р2 делает pull изменений с сервера, в результате у него появляются изменения Р1.
		\item Р2 собирает проект, запускает код. Теперь программа корректно работает
	\end{enumerate}
Можно помочь разработчику избежать ошибки, напомнив ему о том, что нужно к текущим измененным файлам так же модифицировать связанные с ними файлами и включить их в коммит. Модель рекомендации может быть построена так, чтобы предлагать такие <<забытые>> файлы. Однако почти любая модель требует большого набора данных примеров коммитов. Но история репозитория предоставляет нам такой набор данных.
\section{Структуризация данных}
\subsection{Исходные данные}
Для получения необработанных данных использовалось названое раннее хранилище репозиториев -- GitHub. Было склонировано несколько репозиториев. История этих репозиториев анализировалась с помощью встроенных в Git комманд (например, git log). Система контроля версий Git выдает историю репозитория, начиная от самых новых коммитов к самым старым. Чтобы упросить анализ, мы анализировали историю из конца в начало, это помогат отслеживать удаление и переименование файлов.
\subsection{Тренировочный датасет}
Когда история репозитория получена, следующий вопрос -- как определить, какие файлы следует рекомендовать для каждого коммита в истории.
\subsubsection{Формат датасета}
Опишем, как выглядит набор данных. Датасет состоит из строк, где любая отдельная строка содержит несколько частей:
    \begin{enumerate}
		\item Информация о коммите: автор коммита, время коммита, файлы в нем и т.д.
		\item Файл из репозитория.
		\item Единица, если файл должен быть предсказан, иначе -- ноль.
	\end{enumerate}
\subsubsection{Лемма о полном коммите}
Сделаем такое предположение: большинство коммитов в любом репозитории уже содержат полный набор файлов. Учитывая, что коммитов много, коммиты с неполным набором файлов не повлияют на качество рекомендаций.
\subsubsection{Цель}
Если коммит, взятый из репозитория, имеет полный набор файлов, то при удалении файла из этого коммита набор будет неполным. Поэтому цель строится следующим образом: для каждого коммита размера $N$ каждое из его подмножеств размера $N - 1$ берется в качестве первой части, а оставшийся файл считается правильным выходным сигналом -- второй частью строчки датасета. В то же время, система не должна ничего рекомендовать для оригинального коммита, поэтому мы добавляем в датасет некоторое количество строк, где первая часть является текущим коммитом, а вторая часть содержит <<связанный>> файл не из текущего коммита. У такой строчки цель будет равно нулю. <<Связанный>> файл -- это файл, который был в одном и том же коммите с любым из файлов из текущего коммита хотя бы один раз.
\subsection{Тестовый датасет}
Тестовый набор данных имеет тот же формат, что и обучающий набор данных. Самое главное -- никогда не проверять качество системы на данных, которые использовались для обучения этой системы. Поэтому мы проверяем каждый репозиторий на $k$ последних коммитах и обучаем его на остальной истории. Это также имеет и практическое значение -- наша система всегда будет обучаться на данных, полученных в прошлом, значит нам нужно хорошо уметь делать рекомендации в будущем.
\section{Решения}
\subsection{Оценка качества}
Главная цель нашей системы -- рекомендовать полный набор файлов по данному коммиту. Следует отметить, что когда разработчик использует нашу систему, важно не давать неверные рекомендации. Если система не уверена в конкретной рекомендации, то лучше молчать, чем нарушать рабочий процесс разработчика. Исходя из этого предположения, система должна попытаться свести к минимуму количество ложных срабатываний и максимально увеличить количество истинных положительных результатов. Мы должны подумать о том, насколько хороши рекомендации нашей модели со стороны пользователя. Обучающие и тестовые наборы данных были созданы для репозитория IntelliJ IDEA Community. Система рекомендаций по файлам была протестирована на последних 5000 коммитах и обучена на остальных коммитах.
\subsection{Базовый показатель}
Простейшим базовым показателем для нашей системы является получение <<связанных>> файлов, для каждого файла этого набора подсчитайте количество коммитов, в которых содержался этот файл, и порекомендуйте 5 файлов с наибольшим числом.
\subsection{Байесовская оценка}
Следующей попыткой решения поставленной задачи было создание модели баесовской оценки, используя формулу для голосований:
    $$W = v\frac{R}{m + v} + m\frac{C}{m + v},$$
$W$ -- оценка файла, \\
$v$ -- число голосов за то, чтобы предсказать файл, \\
$m$ -- минимальное число голосов за файл $= 3.2$, \\
$R$ -- средняя оценка для файла за предыдущие голосования, \\
${C}$ -- средняя оценка для всех файлов $= 0.25$. \\
Для каждого файла из текущего коммита 20 последних коммитов, содержащих этот файл, извлекаются из истории. После этого каждый из этих извлеченных коммитов голосует за файлы, содержащиеся в нем (исключая файлы от текущего коммита). Величина голоса рассчитывается по формуле: $\min(1.0, \frac{{commit\_size}}{{size}})$\\
$commits\_size$ --  максимальное число файлов в голосующем коммите, чтобы получить максимальную величину голоса $= 8.0$,\\
$size$ -- число файлов в голосующем коммите\\
Результаты из разных файлов складываются. Файл будет рекомендован, если его оценка выше чем порог $= 0,55$.
\section{Планы на будущее}
Наша система считается успешной, когда она предлагает разработчикам некоторые файлы, и они изменяют коммит, добавляя эти файлы более чем в 90\% случаев. Так что есть куда совершенствоваться.
\printmainbibliography

\end{document}