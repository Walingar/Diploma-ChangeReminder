Появление систем контроля версий дало большой толчок для появления и развития все более и более крупных команд, которые занимаются разработкой программного обеспечения. Они помогают каждому разработчику сохранить проделанную им работу локально или на сервер независимо от коллег, а затем в один момент соединить написанный код в один единый продукт и отдать его пользователям. В среднем разработчик в большом проекте делает несколько фиксаций изменений на сервере в день. Но, что если один из разработчиков зафиксировал изменения, которые приводят состояние проекта в неконсистентное состояние, например, проект перестал компилироваться, какие-то тесты не проходятся или просто часть функциональности перестала работать. Тогда, коллеги, которые попытаются обновить проект с версии сервера, будут остановлены в работе. Им нужно будет ждать, пока разработчик, повредивший состояние проекта, не восстановит его. И, конечно, лучше предотвратить эту ошибку заранее, сказать разработчику о том, что он ошибся, что его изменения могут повредить состояние проекта, хоть и временно. 

Для обнаружения ошибок разработчика на ранней стадии уже существует множество инструментов. Если говорить о компилируемых языках, то одним из главных показателей того, что программа будет работать (не обязательно корректно) является компиляция кода. Проблема подхода <<скомпилировалось, значит работает>> состоит в том, что компиляция в большинстве случаев не отслеживает ошибки программиста связанные с кодом, который работает некорректно, а только помогает понять, что программу можно запустить. Одним из инструментов нахождения ошибок связанных с некорректной работой кода является статический анализ кода. Он представляет из себя мощный инструмент, который позволяет находить наиболее частые ошибки в разработке программного обеспечения. Статический анализ используется практически всеми разработчиками в той или иной степени. В статье \cite{static-analysis} был проведен сравнительный анализ нескольких утилит для статического анализа, который показывает, что нет решения, которое покрывало бы все ошибки разработчика. Важный момент, что количество кода в проектах постоянно растет, а значит и время компиляции и статического анализа тоже растет, и, начиная с некоторого момента, уже становится сложным скомпилировать код локально, не говоря о сложных методах статического анализа.

Большинство статических анализаторов используют эвристики, выведенные другими разработчиками. С целью автоматизации данного процесса стали появляться решения, которые используют методы машинного обучения для обнаружения и исправления ошибок разработчика. Например, в статье \cite{static-analysis-ml} авторы разработали модель, которая в 50\% случаев может правильно исправить ошибку компиляции для языка программирования Java. В решении не использовались какие-то конкретные эвристики, модели сгенерированы на основе собранных данных. Здесь стоит отметить важный для выпускной работы момент~--- на данный момент количество проектов, использующих системы контроля версий, существует огромное множество, таким образом образуя большую кодовую базу. Некоторая её часть является открытой, например, сайт <<GitHub>> на январь 2020 года содержал более чем 28 миллионов открытых проектов. Такая кодовая база неявно хранит в себе шаблоны поведения разработчиков, настройки их окружения и другие интересные для анализа данные. Используя этот набор данных, появляется возможность помочь разработчикам избежать ошибок, приводивших к неконсистентному состоянию проекта в прошлом.

Рассмотрим ситуацию, в которой разработчик забыл вместе с зафиксированными файлами изменить и добавить в проект важный для работоспособности кода файл, но в то же время программа успешно компилируется. Такую ошибку не сможет обнаружить компилятор. Если этот файл был специфичным для проекта, то такую ошибку не сможет обнаружить и стандартный статический анализатор, а разработка собственного быстрого анализатора~--- дело не простое. Но если проект сохраняется в систему контроля версий, то вполне возможно, что информация о том, что нужно добавить этот файл в месте с остальными, там содержится. В рамках выпускной работы была поставлена цель разработать плагин, который будет обнаруживать такой вид ошибок и показывать это пользователю. Для достижения поставленной цели было проделано несколько этапов. Вначале было решено, что плагин будет работать для системы контроля версий Git, как самой популярной на момент написания работы (следует из рейтинга в источнике \cite{best-vcs}). В первой главе были проанализированы инструменты для реализации плагина и методы для предсказания забытых для модификации файлов. Во второй главе были подробно описаны использованные при разработке методы. Затем в третьей главе была разработана модель машинного обучения для рекомендации файлов забытых для модификации. Простая модель машинного обучения, конечно, является достаточно бесполезной, если её не применять на практике. Для этого в четвертой главе были разработаны и реализованы два плагина для платформы IntelliJ, которые показывали разработчику рекомендации о том, что, возможно, он забыл модифицировать важный для консистентности проекта файл.