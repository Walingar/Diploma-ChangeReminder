Перед началом выполнения выпускной квалификационной работы следует поставить цель и задачи, которые помогут достигнуть заданной цели. Цель будет основана на некоторых определениях и понятиях, о них и будет рассказано в данной главе.
\section{Машинное обучение}
Начало обзора предметной области будет посвящено такой дисциплине как машинное обучение. В современном мире информационных технологий слово <<предсказание>> у многих сразу ассоциируется с термином машинное обучение. И данная работа не исключение, в ней за основу модели предсказаний также будет выступать модель машинного обучения. 

Машинное обучение (далее может использоваться как ML, от английского Machine Learning)~--- это раздел науки о создании интеллектуальных алгоритмов, изучающий методы, которые строят математическую модель, решающую поставленную задачу, а не решают задачу напрямую \cite{ml-main-book}. Машинное обучение бывает двух типов: по прецедентам и дедуктивное. В современном мире можно считать, что машинное обучение и обучение по прецедентам~--- это одно и то же, поэтому будем говорить именно об этом типе обучения. Оно основано на создании математической модели, используя раннее эмпирически собранный набор данных. В свою очередь, машинное обучение подразделяется на несколько способов: обучение с учителем, обучение без учителя, обучение с подкреплением, активное обучение и много других видов \cite{ml-methods-book}. Рассмотрим подробнее способ, который будет использоваться в работе, обучение с учителем.
    \subsection{Обучение с учителем}
Обучение с учителем~--- способ машинного обучения, в ходе которого математическая модель обучается на наборе данных состоящим из пар входные данные и выходные данные \cite{ml-methods-book}. Обученная модель должна получать входные данные в том же формате, что и данные в исходном наборе данных и возвращать выходные. Модель обучается таким образом, чтобы метрика между выходными данными модели и выходными данными в наборе было минимальным. Метрика задается отдельно для каждой задачи. Важным моментом в процессе минимизации метрики является то, что нельзя проверять её на тех же данных, на которых происходило обучение \cite{cross-validation-article}. Распространённым методом анализа поведения обученной математической модели на независимых данных является перекрёстная проверка. 
    \subsection{Перекрёстная проверка}
Перекрёстная проверка~--- метод оценки математической модели на независимых данных \cite{cross-validation-article}. Этот метод является одним из самых используемых инструментов в машинном обучении. Перекрёстная проверка заключается в разбиении имеющейся выборки на $k$ частей. $k - 1$ часть используется для обучения математической модели, оставшаяся часть используется для оценки качества обученной модели. Этот шаг повторяется $k$ раз, чтобы каждая часть поучаствовала в оценке качества независимо. Таким образом, усреднив полученные результаты, будет получена наиболее вероятная оценка метрики модели на независимых данных \cite{cross-validation-non-main}.
    \subsection{Задача классификации}
В рамках выпускной квалификационной работы будет решаться одна из задач обучения с учителем~--- задача классификации. Задача отличается от других тем, что выходные данные представляют из себя конечное множество, называемое метками классов \cite{classification-task}. Таким образом, обученная модель должна выдавать для входных данных одну из меток классов из обучающей выборки. Существует несколько видов задачи классификации: двухклассовая, многоклассовая, непересекающиеся классы, пересекающиеся классы. В выпускной квалификационной работе решалась задача двухклассовой классификации с непересекающимися классами. Для решения задачи классификации существует большое количество методов, например: байесовский классификатор, нейронная сеть, решающие деревья и так далее.
\section{Система контроля версий Git}
Данные для обучения и оценки модели машинного обучения в рамках выпускной квалификационной работы были собраны из сервиса GitHub основанного на системе контроля версий Git. В данном разделе будет рассказано об устройстве данной системы контроля версий.
    \subsection{Системы контроля версий}
Система контроля версий (в дальнейшем может использоваться как VCS от английского Version Control System)~--- инструмент, позволяющий сохранять версии файлов и возвращаться к одной из сохранённых версий \cite{vcs-definition}.

История систем контроля версий начинается с появления первых локальных систем контроля версий, например Revision Control System (RCS). Причиной их появление служило то, что раннее сохранять версии приходилось вручную, создавая папки и копируя файлы из одной папки в другую. Разработчики локальных систем контроля версий стремились автоматизировать сохранение версий измененных файлов, что и привело к созданию RCS. Данная VCS хранила информацию обо всех изменениях выбранных для хранения файлов в специальном хранилище, которое называется репозиторий (repository). Но, команды по разработке программного обеспечения непрерывно росли. И важной частью процесса разработки стало взаимодействие программистов между собой. Использование локальных систем контроля версий не предусматривало простой способ обмена версиями.

Следующим этапом развития систем контроля версий стало создание централизованных систем контроля версий. Их основным отличием от локальных VCS является то, что информация о версиях хранится на сервере. Теперь, чтобы сохранить изменения, нужно отправить их на сервер. Но в то же время, клиенты могут скачать любую версию с сервера. Тем самым разработчики могут с лёгкостью взаимодействовать между собой. Примером централизованных систем контроля версий являются Perforce, Subversion (SVN), Concurrent Versions System (CVS). Данные VCS были стандартным решением для хранения версий. Но, коммуникация между разработчиками всегда проходила через сервер. Таким образом, существует единая точка отказа~-- сервер. Если у клиента теряется доступ к серверу, то он не может сохранять версии своих локальных изменений.

В данный момент системы контроля версий находятся на этапе распределенных систем контроля версий, которые стали заменять собой централизованные системы. Их особенность состоит в том, что теперь клиенты скачивают с сервера не только одну версию, а весь репозиторий целиком, и сами являются сервером. Таким образом, у каждого пользователя распределенной системы контроля версий локально находится полная копия репозитория на момент синхронизации. В таком случае разработчик может сохранять свои изменения в локальный репозиторий, как это происходило с локальными системами контроля версий. А затем, когда появляется соединение с сервером, он может отправить свои изменения файлов на сервер. С помощью такой системы пропадает единая точка отказа, которая присутствовала в централизованных системах контроля версий. Существует большое количество распределенных систем контроля версий, самые популярные из них: Git, Mercurial \cite{best-vcs}. 

В последствии стали появляться сервисы, которые позволяют арендовать сервера для хранения репозиториев, многие из них позволяют делать это бесплатно. Один из самых популярных сервисов является GitHub, который использует распредененную систему контроля версий Git. Важно заметить, что на январь 2020 года у этого сервиса арендовали более чем 28 миллионов репозиториев \cite{github-repo-count}. Каждый из них содержит множество версий кода, которые неявно хранят в себе шаблоны поведения разработчиков, настройки их окружения и другие интересные для анализа данные. В рамках данной работы для обучения и анализа математической модели использовался приведенный сервис.
    \subsection{Система контроля версий Git}
Для того, чтобы получать и анализировать данные из системы контроля версий Git, следует изучить то, как она устроена. 
\section{Платформа для создания интегрированных сред разработки IntelliJ}

\section{Обзор материалов посвященных анализу Git репозиториев и поиску зависимостей в них}
Перед началом выполнения выпускной работы были проанализированы несколько статей на тему дипломной работы и смежные темы. В мировом индексе представлено множество работ, где рассказано о том, как можно использовать исторические данные в процессе разработки программного обеспечения с целью повышения качества этого процесса. Был подход использования кодовой базы для поиска логически связанных модулей, чтобы отследить, какие файлы изменяются вместе \cite{logical-modules}. В статье \cite{source-change} автор разрабатывал систему предсказаний о том, какие изменения внесет разработчик в кодовую базу. Были проанализированы статьи, которые не имеют непосредственного отношения к выпускной работе, но подходы из этих статей использовались при разработке модели предсказаний. Например, одна из таких статей \cite{project-memory}. В данной статье авторы разработали приложение <<Hipikat>>, позволяющее новым участникам быстрее ознакомится с программной системой, с которой им предстоит работать.


\section{Формальная постановка задачи предсказания забытых для модификации файлов на основе Git репозитория}
Введем понятие репозиторий (от английского repository)~-- это ориентированный ациклический граф, где каждое ребро представляет из себя отношение <<быть родителем>>. Вершину данного графа будем называть коммит (от английского commit). Коммит содержит в себе свойства: множество файлов $Files \subseteq File^k$ и мета-информацию (время создания, автор, название коммита). $File \in \mathbb{N}$ -- идентификатор файла в репозитории.\\
\subsection{Требования к модели рекомендации}\label{ml-model-req}
Пусть нам даны репозиторий и коммит из него. Файлы из этого коммита обозначим $TargetCommitFiles \subseteq File^k$. Требуется по данным множеству $CommitFiles \subseteq TargetCommitFiles$, мета-информации о коммите и всех потомках коммита возвращать $TargetCommitFiles$.
\subsection{Требования к реализации плагина для IntelliJ платформы}\label{impl-req}
Требуется разработать плагин для платформы IntelliJ, который во время пользовательского коммита будет рекомендовать пользователю модифицировать и добавлять в коммит файлы из репозитория. Плагин должен быть основан на модели, требования к которой изложены в \ref{ml-model-req}. В худшем случае время работы плагина должно составлять не более двух секунд на процессоре 2,2 GHz Quad-Core Intel Core i7. В худшем случае, потребление памяти должно быть не более 10 Мегабайт.

\chapterconclusion