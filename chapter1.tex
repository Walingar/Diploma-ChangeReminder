Проектная информация хранится в специальной базе данных, которая называется репозиторий. Репозиторий состоит из некоторого множества снимков изменений, которые именуются коммит. Каждый коммит в свою очередь состоит из ссылки на предыдущий коммит (если таковой имеется), мета-информации (сообщение, автор, время коммита) и самих зафиксированных изменений. 
\section{Обзор материалов посвященных анализу Git репозиториев и поиску зависимостей в них}
Перед началом выполнения выпускной работы были проанализированы несколько статей на тему дипломной работы и смежные темы. В мировом индексе представлено множество работ, где рассказано о том, как можно использовать исторические данные в процессе разработки программного обеспечения с целью повышения качества этого процесса. Был подход использования кодовой базы для поиска логически связанных модулей, чтобы отследить, какие файлы изменяются вместе \cite{logical-modules}. В статье \cite{source-change} автор разрабатывал систему предсказаний о том, какие изменения внесет разработчик в кодовую базу. Были проанализированы статьи, которые не имеют непосредственного отношения к выпускной работе, но подходы из этих статей использовались при разработке модели предсказаний. Например, одна из таких статей \cite{project-memory}. В данной статье авторы разработали приложение Hipikat, позволяющее новым участникам быстрее ознакомится с программной системой, с которой им предстоит работать.
\section{Существующие решения задачи поиска релевантных файлов в Git репозитории}
На данный момент существует решение поставленной задачи, которое называется git-also. Программа является приложением для командной строки. Оно позволяет для заданного файла получить набор файлов, с которыми введенный файл был в большем числе коммитов вместе. Данное решение не соответствует требованию, представленному в пункте \ref{impl-req}, т.к. приложение не является плагином для платформы IntelliJ. Также, данное приложение может решать задачу поставленную в пункте \ref{ml-model-req} только с использованием множества запросов. При внимательном рассмотрении данного решения, можно заметить, что оно использует простую решающую функцию, которая будет являться для нас базовым показателем (см. пункт \ref{baseline}).
\chapterconclusion