На момент начала разработки и реализации плагина уже был разработан интерфейс модели предсказания забытых для модификации файлов на основе Git репозитория. Во второй главе были разобраны инструменты и методы, с помощью которых в текущей главе будут реализованы плагины для платформы IntelliJ.
\section{Плагин GitAlso}\label{git-also-main}
Первой реализацией задачи, поставленной в пункте \ref{impl-req}, был GitAlso плагин для IntelliJ платформы. Стоит отметить, что совпадение названий GitAlso и консольной утилиты git-also, представленной в пункте \ref{git-also-anvaka-label} является случайным. Консольная утилита появилась на несколько месяцев раньше начала разработки плагина GitAlso, но она не была еще настолько популярной, чтобы появляться в выдаче на запросы. И только после реализации плагина GitAlso было обнаружено существование утилиты git-also.
\subsection{Архитектура}
\begin{figure}[!h]
\caption{Схема архитектуры плагина GitAlso}\label{GitAlso-arch}
\centering
\includegraphics[scale=0.37]{images/GitAlsoArch.png}
\end{figure}
На рисунке \ref{GitAlso-arch} представлена схема архитектуры GitAlso плагина. Зеленым цветом отмечены части, реализованные автором работы, желтый цвет отображает компоненты, которые были реализованы в платформе IntelliJ до начала выполнения работы.

В IntelliJ платформе, а именно в VCS (Version Control System) части платформы уже была реализована точка расширения для создания компонентов, исполняемых перед пользовательским коммитом ~--- $CheckinHandler$ (более подробно об интерфейсе описано в пункте \ref{chapter2-vcs}). Эти компоненты имеют доступ к мета-информации о коммите и файлах, которые должны быть сохранены в репозиторий. Для того, чтобы модель предсказаний выводила рекомендацию следует в дополнение к имеющейся информации получить историю этого самого репозитория в виде множества коммитов (ожидается, что эти коммиты будут <<связанными>>, более подробно об этом сказано в пункте \ref{related-files-intro}). Для получения такой истории нам нужно по заданному набору файлов получить коммиты, в которых эти самые файлы присутствовали. В VCS части IntelliJ платформы, а точнее в реализации систем контроля версии, основанной на реализации VCS части (в данном случае реализация представлена в плагине Git4Idea, который можно найти в репозитории \cite{ij-community}), уже присутствуют обратные индексы для коммитов, получить их можно с использованием компоненты $VcsLogIndex$. Обратные индексы позволяют по данным файлам быстро узнать идентификаторы коммитов, в которых эти файлы присутствовали. Но одних идентификаторов коммитов недостаточно, для модели требуется для каждого коммита передать мета-данные и файлы, которые сохранялись в данном коммите. О получении информации о коммите по индексу будет рассказано в \ref{forward-index}. Для фильтрации истории только по <<связанным файлам>> была реализована компонента $FileHistoryProvider$. Таким образом, при создании пользователем коммита создается $GitAlsoCheckinHandler$, который передает в $FileHistoryProvider$ информацию о текущем коммите. $FileHistoryProvider$ проверяет, собран ли обратный индекс, если индекс готов, то $FileHistoryProvider$ собирает историю по данному коммиту и отдает их в $PredictionProvider$, который является мостом между плагином и ML моделью. Затем, рекомендация возвращается обратно по цепочке до $GitAlsoCheckinHandler$ и предсказание модели показывается в пользовательском интерфейсе, как это показано в пункте \ref{git-also-ui}. Работа пользователя с интерфейсом записывается в статистику, как это описано в пункте \ref{gitalso-stats}. Для подсчета предсказаний использовалась модель байесовского среднего, представленная в пункте \ref{chapter3-bayes}.

Следует обратить особое внимание на то, что создание $GitAlsoCheckinHandler$ и вызов методов у него осуществляется на потоке, на котором происходит отрисовка интерфейса, а это значит, что если подсчет рекомендации будет занимать длительное время, то пользовательский интерфейс будет не доступен долгое время. Чтобы этого избежать, следует выполнять все подсчеты в фоновом процессе, показывая индикацию прогресса.
\subsection{Прямой индекс}\label{forward-index}
Важным моментом в реализации плагина является получение информации о коммитах из репозитория. Приложению необходимо уметь по данному множеству идентификаторов коммитов возвращать их мета-информацию и файлы, которые в них изменялись. Для выполнения поставленной задачи автором работы был реализован прямой индекс. Его основной положительной стороной является быстрое получение информации о коммите по идентификатору данного коммита, притом реализованный прямой индекс умеет отслеживать переименования файлов. Но реализованный прямой индекс на больших репозиториях занимал существенное количество места на пользовательском диске. Для репозитория intellij-community на 20 декабря 2019 года прямой индекс занимал 400 мегабайт на жестком диске. Поэтому было решено использовать запрос в Git для получения информации о коммите, и, таким образом, происходит замедление получения данной информации, но Git позволяет делать один запрос сразу для нескольких коммитов. Вместе с ограничениями к моделям получилось так, что хватает одного запроса на то, чтобы получить информацию обо всех нужных коммитах.
\subsection{Пользовательский интерфейс}\label{git-also-ui}
\begin{figure}[!h]
\caption{Пользовательский интерфейс плагина GitAlso}\label{git-also-screen}
\centering
\includegraphics[scale=0.6]{images/GitAlso.png}
\end{figure}
Пользовательский интерфейс плагина должен показывать файлы, который пользователь возможно <<забыл>> изменить. Для показа таких файлов было решено открывать диалог ($GitAlsoDialog$) с деревом файлов. Для показа дерева файлов использовалось готовое решение из платформы IntelliJ, которое называется $ChangesBrowser$. Пример показа рекомендации можно увидеть на рисунке  \ref{git-also-screen}.
\subsection{Персонализация решающей функции}
Для улучшения качества показываемых рекомендаций было принято решение использовать взаимодействие пользователя с плагином в целях изменения границы срабатывания решающей функции ($threshold$ из третьей главы). На основе нажатий пользователем кнопок Commit Anyway и Cancel мы будем обновлять границу, используя метод $updateState$ приведенный в листинге \ref{personalization}, и сохранять ее в локальное состояние.
\section{Плагин ChangeReminder}\label{changereminder-main}
На основе собранной с помощью методов, представленных в пункте \ref{gitalso-stats}, статистики и анализа данной статистики, описанного в пункте \ref{bayes-quality-online}, можно сделать вывод, что реализованный плагин GitAlso выполняет требования, поставленные в пунктах \ref{impl-req} и \ref{ml-model-req}.Но, появились отзывы, которые утверждали, что показ модального диалога, даже с качеством решающей функции $0,5$, мешает пользовательскому процессу в половине случаев, что неприемлемо для добавления такой функциональности в IDE по умолчанию. Автором работы было принято решение улучшить пользовательский интерфейс плагина GitAlso представленный в пункте \ref{git-also-ui}, переместив функциональность плагина из компоненты, которая работает перед пользовательским коммитов, во вкладку Local Changes. В приведенной вкладке показаны файлы, который пользователь модифицировал, добавил, удалил из системы контроля версии. Таким образом, пользователь может видеть предсказание, данное моделью, в любое время редактирования кода, а не только перед совершением коммита. Вместе с идеей о том, что нужно переносить функциональность GitAlso плагина, была обучена модель случайного леса, представленная в пункте \ref{chapter3-forest}, она показала качество на сгенерированном датасете лучше, чем модель байесовского среднего, поэтому было решено сразу обновить модель на новую.

Представим, что пользователь будет сохранять в репозиторий все файлы, которые расположены в его списке изменений по умолчанию. Теперь будем делать рекомендации для данных файлов при каждом их изменении и при изменении репозитория. В связи с такими изменениями было решено создать новый плагин и назвать его ChangeReminder. По большей части функциональность плагина основана на плагине GitAlso, но есть и существенные изменения в архитектуре.
\subsection{Архитектура}
\begin{figure}[!h]
\caption{Схема архитектуры плагина ChangeReminder}\label{ChangeReminder-arch}
\centering
\includegraphics[scale=0.36]{images/ChangeReminderArch.png}
\end{figure}
Архитектура ChangeReminder плагина представлена на рисунке \ref{ChangeReminder-arch}. Желтым цветом отмечены компоненты, которые были реализованы в IntelliJ платформе до выполнения работы, зеленым цветом отмечены части, реализованные автором работы.\\

Рекомендация файлов пользователю происходит по следующему алгоритму:
    \begin{itemize}
        \item Пользователь модифицирует файл/изменяется состояние одного из репозиториев.
        \item $ChangeListManager$ или $VcsProjectLog$ сообщают в $PredictionService$ о том, что состояние репозитория изменилось.
        \item $PredictionService$ запрашивает у $UserSettings$ включен ли плагин, и если нет, то дальнейшие действия не происходят.
        \item $PredictionService$ получает текущие изменения из $ChangeListManager$.
        \item $PredictionService$ отправляет $PredictionRequest$ на обработку в $PredictionController$.
        \item $PredictionController$ синхронизирует запросы, отменяя прошлые. 
        \item $PredictionController$ отправляет $PredictionRequest$ в $FileHistoryProvider$
        \item $FileHistoryProvider$ запрашивает у $VcsLogIndex$ обратный индекс для текущих репозиториев и на его основе собирает историю репозитория, которую отдает в $PredictionProvider$. Если индекс еще не готов, то дальнейшие действия не происходят.
        \item $PredictionProvider$ занимается обработкой запроса и отдает $PredictionData$~--- результат работы в $PredictionController$ и оттуда в $PredictionService$.
        \item $PredictionService$ запрашивает обновление у $ChangeReminderViewModifier$
        \item $ChangeReminderViewModifier$ из данной $PredictionData$ создает $ChangeReminderBrowserNode$, которая рисуется в пользовательском интерфейсе.
    \end{itemize}
    
    
$PredictionService$ и действия пользователя с интерфейсом записываются в сервисе Feature Usage Statistics (см. пункт \ref{changereminder-stats}). Рассмотрим каждую компоненту подробнее:\\


$UserSettings$~--- наследник $SimplePersistentStateComponent$, который используется для сохранения информации в локальное хранилище. В данном классе сохранено состояние $isPluginEnabled$, которое показывает, должен ли плагин делать рекомендации или нет. На изменения $UserSettings$ можно подписаться, используя реализацию интерфейса $PluginStatusListener$.\\


$ChangeListManager$~--- менеджер, который хранит информацию о состоянии списков изменений, которые показываются во вкладке Local Changes. На изменения состояния менеджера можно подписаться используя реализацию интерфейса $ChangeListAdapter$.\\


$VcsLogIndex$~--- класс, который подсчитывает и хранит обратный индекс для каждого репозитория. На окончание подсчета обратного индекса можно подписаться, используя реализацию интерфейса $VcsLogIndex.IndexingFinishedListener$. На создание нового индекса или удаление старого можно подписаться, используя реализацию интерфейса $VcsProjectLog.ProjectLogListener$\\. Важный момент, который стоит отметить: события от слушателей могут приходить из разных потоков, поэтому важно сделать сервис, который является потокобезопасным.\\


$PredictionProvider$~--- класс модели машинного обучения, разработанной в третьей главе работы. Его главной задачей является предоставление рекомендации на основе данного коммита и истории репозитория.\\


$PredictionController$~--- имплементация интерфейса $SingleTaskController$. Главной задачей данного класса является контроль за выполнением подсчета рекомендации. Благодаря этому сервису подсчет осуществляется в одном потоке, притом при появлении нового запроса на подсчет, предыдущий прерывается, и выполняется новый в том же потоке. С помощью данного компонента происходит синхронизация предсказаний. Пользователю не выведется на экран старое предсказание для новых модификаций.\\


$PredictionRequest$~--- класс, который умеет получать данные, нужные для работы модели предсказаний. На рисунке \ref{ChangeReminder-arch} он показан как <<Файлы>>, которые передаются в $PredictionController$\\


$PredictionData$~--- класс, представляющий из себя алгебраический тип данных. Он может быть или $Prediction$ и содержать файлы рекомендованные моделью, или быть $EmptyPrediction$ и содержать причину, по которой предсказание не было подсчитано. На рисунке \ref{ChangeReminder-arch} он изображен, как <<Рекомендация>>.


$ChangesViewModifier$~--- интерфейс разработанный автором работы. Он позволяет добавлять новые вершины с детьми в дерево, представленное во вкладке Local Changes. В плагине используется реализация этого интерфейса $ChangeReminderViewModifier$. В последствии этот интерфейс использовался, например, в Git4Idea плагине для того, чтобы показывать вершину в Local Changes с модификациями из предыдущего коммита. \\

$PredictionService$~--- основной потокобезопасный класс реализации ChangeReminder плагина. Его задачами является слушать изменения в сервисах указанных выше, отдавать новые данные в $PredictionController$ для дальнейшего подсчета рекомендации, получать результат в виде $PredictionData$, создавать запрос в Feature Usage Statistics на добавление статистики о данной рекомендации и отдавать рекомендацию на отрисовку в $ChangesViewModifier$. Основной задачей, которую должен решить данный класс~--- подсчет предсказаний должен начинаться сразу после изменения состояния проекта и показываться всегда должна вершина с последним посчитаным предсказанием.

\subsection{Пользовательский интерфейс}
\begin{figure}[!h]
\caption{Пользовательский интерфейс плагина ChangeReminder}\label{ChangeReminder-ui}
\centering
\includegraphics[scale=0.4]{images/ChangeReminderUI.png}
\end{figure}
Пользовательский интерфейс плагина ChangeReminder представляет из себя вершину в дереве изменений во вкладке Local Changes (см. рисунок \ref{ChangeReminder-ui}). Вершина называется People who change the files in the active changelist also change. Если рекомендация составляет пустое множество файлов, то вершина становится невидимой.


\section{Сбор статистики}\label{stats-main}
Для того, чтобы понимать, насколько хорошо работает обученная решающая функция у пользователей в реальных условиях, а не на искусственно созданном наборе данных, было решено использовать сбор статистики. Также с помощью пользовательских логов можно понять, что нужно изменить в модели, чтобы число благоприятных исходов увеличилось. Для этого были записаны факторы для пар файлов, которые использовались для их для дальнейшего обучения. Не стоит забывать о том, что интерфейс плагина должен подходить пользователям. Используя статистику, можно понять реакцию пользователей на рекомендации. Для этого был посчитан процент случаев, когда пользователь смотрел на предложенные файлы и когда проигнорировал нашу рекомендацию. Всего автором работы было сделано две реализации сбора пользовательской статистики. Вначале статистика собиралась с использованием серверов User Logs, затем был совершен переход на более современный встроенный в IntelliJ платформу сервис~--- Feature Usage Statistics (FUS).
\subsection{Сбор статистики в плагине GitAlso с использованием серверов User Logs}\label{gitalso-stats}
Первая итерация сбора пользовательских логов использовала сервера внутреннего сервиса сбора статистики User Logs. Общение с User Logs серверами происходит по протоколу HTTP. Статистика пользователя для User Logs представляется в виде множества строк отчета, их формат будет изложен в разделе \ref{report-line}. Отправлять пользовательские логи можно как в сжатом, так и в текстовом виде (для этого используются разные url). Анализ данных, собранных на основе данной архитектуры представлен в пункте \ref{bayes-quality-online}.
\subsubsection{Модель пользовательских логов}
Пользовательские логи в User Logs представляют из себя конечный автомат. Состояние автомата~--- это данные описывающие состояние системы. А переход~--- это пользовательское действие.
\subsubsection{Строка отчета плагина}\label{report-line}
Каждая строка отчета, отправляемого в User Logs, представляет из себя части соединенные символом табуляции:
    \begin{itemize}
        \item $timestamp$~--- время, когда произошло пользовательское действие.
        \item $recorderId$~--- идентификатор отправителя статистики.
        \item $recoderVersion$~--- версия отправителя статистики.
        \item $userId$~--- идентификатор пользователя (создается при установке IDE).
        \item $sessionId$~--- идентификатор сессии (создается при открытии IDE).
        \item $bucket$~--- идентификатор группы (используется для A/B экспериментов).
        \item $actionType$~--- идентификатор действия пользователя.
        \item $actionJson$~--- информация о состоянии, в которое перешел пользователь.
    \end{itemize}

Рассмотрим конкретнее, какие типы действий пользователя отправлялись плагином:
    \begin{itemize}
        \item $COMMIT\_CLICKED$~--- нажатие кнопки Commit в Commit Dialog.
        \item $CANCEL$~--- нажатие кнопки Cancel.
        \item $COMMIT$~--- нажатие кнопки Commit Anyway.
    \end{itemize}

В информации о состоянии содержался $json$, в котором было несколько полей:
    \begin{itemize}
        \item $REPOSITORY$~--- уникальный для пользователя идентификатор репозитория.
        \item $FILES$~--- уникальные для репозитория идентификаторы файлов в коммите.
        \item $TIME$~--- время, затраченное на подсчет рекомендации.
        \item $PREDICTION$~--- уникальные для репозитория идентификаторы файлов, рекомендованные для модификации и добавления в коммит.
        \item $FACTORS$~--- факторы посчитанные для каждого рекомендованного файла.
    \end{itemize}
Идентификаторы репозитория, файлов и коммитов создает IntelliJ платформа. По данным идентификаторам нельзя идентифицировать пользователя. Таким образом, никакой приватной информации не отправляется. К тому же, при первом запуске IDE с плагином пользователю показывается нотификация о том, что плагин отправляет полностью анонимные данные для улучшения качества решающей функции.
\subsubsection{Реализация записи и отправки пользовательских логов}
\begin{figure}[!h]
\caption{Схема записи и отправки пользовательских логов}\label{jet-stat-logs}
\centering
\includegraphics[scale=0.15]{images/User Logs.png}
\end{figure}
Реализация записи и отправки пользовательских логов показана на рисунке \ref{jet-stat-logs}. Принцип работы является достаточно популярным. При совершении пользователем какого-то действия над интерфейсом, это действие отправляется к менеджеру хранилища, который создает правильные строки отчета и сохраняет их в локальное хранилище. После этого менеджер хранилища отправляет запрос отправителю логов, чтобы сервис отправил накопившиеся данные на сервер. Если данных в локальном хранилище достаточно, то из них отправитель логов собирает HTTP запрос на сервер. Затем идет переход к одной из самых важных частей реализации~--- валидаторам. Перед тем, как отправлять данные на сервер, очень важно понять, не нарушена ли их консистентность (например, пользователю была показана рекомендация, но он ничего с ней не сделал). Для проверки консистентности данных был создан валидатор, который присутствует, как на стороне клиента, так и на стороне сервера. Только после того, как HTTP запрос прошел валидацию на клиентской стороне, он отправляется на сервер User Logs, где расположен серверный валидатор. Если пришедшие данные консистентны, то они сохраняются на сервер и ждут дальнейшей обработки.

\subsection{Сбор статистики в плагине ChangeReminder с использованием Feature Usage Statistics}\label{changereminder-stats}
В плагине ChangeReminder было решено перейти на новый способ сбора статистики с использованием сервиса встроенного в IntelliJ платформу~--- Feature Usage Statistics (FUS).
\subsubsection{Модель пользовательских логов}
Пользовательские логи сервиса FUS представляют из себя набор событий системы. Часто, но не всегда, эти события порождаются действиями пользователя.
\subsubsection{Реализация отправки пользовательских логов}
Отправка пользовательских логов с помощью сервиса FUS является более простой, в сравнении с отправкой статистики на сервера User Logs. Feature Usage Statistics сам занимается хранением, валидацией и отправкой данных. Нашему приложению достаточно собрать $FeatureUsageData$ объект и передать его в FUS.

ChangeReminder отправляет несколько видов событий:
    \begin{itemize}
        \item $CHANGES\_COMMITTED$~--- пользователь сделал коммит из IDE.
        \item $CHANGELIST\_CHANGED$~--- пользователь изменил какой-то файл в репозитории.
        \item $NODE\_EXPANDED$~--- пользователь раскрыл вершину, в которой показано предсказание.
    \end{itemize}
Каждое из событий может содержать поля (возможно, пустые):
    \begin{itemize}
        \item $CUR\_MODIFIED\_FILES$~--- текущие модифицированные пользователем файлы в репозитории.
        \item $PREV\_MODIFIED\_FILES$~--- файлы, которые были модифицированы пользователем перед событием.
        \item $DISPLAYED\_PREDICTION$~--- файлы, предсказанные моделью.
        \item $COMMITTED\_FILES$~--- файлы, которые закоммитил пользователь.
        \item $PREDICTION\_FOR\_FILES$~--- файлы, для которых было сгенерировано предсказание $DISPLAYED\_PREDICTION$.
    \end{itemize}
На основе данной статистики в пункте \ref{forest-quality-online} было оценено качество решающей функции.
\section{Практическое применение}
Плагин GitAlso был добавлен в репозиторий плагинов \cite{plugins-jetbrains}. На момент написания пояснительной записки плагин скачали более 650 раз. Из собранной статистики было определено, что около 64\% пользователей продолжают использовать функциональность плагина после трех предсказаний. 

Плагин ChangeReminder был добавлен по умолчанию в IDE на платформе IntelliJ: IDEA, PyCharm, WebStorm, PhpStorm, CLion, AppCode, RubyMine, GoLand, Rider~--- начиная с версии 2019.2. Более 1000 пользователей отправляли статистику по использованию данного плагина. На ее основе было определено, что около 58\% пользователей продолжают использовать функциональность плагина после трех раскрытий вершины во вкладке Local Changes.
\chapterconclusion
В представленной главе автором работы была разработана, а затем реализована, архитектура двух плагинов для платформы IntelliJ, предсказывающих забытые для модификации файлы на основе Git репозитория. Была разобрана важная составляющая данных плагинов~--- сбор пользовательской статистики использования. На основе собранной статистики в третьей главе был проведен анализ качества решающих функций. Были выполнены подзадачи, поставленные в пункте \ref{chapter2-plugin-req}. Исходя из этого, оба плагина выполнили поставленные в пунктах \ref{impl-req} и \ref{ml-model-req} задачи.